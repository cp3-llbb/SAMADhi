from __future__ import unicode_literals
"""
Object representation of the SAMADhi database tables (based on peewee)

Example:
>>> from cp3_llbb.SAMADhi.SAMADhi import * ## import models and SAMADhiDB
>>> with SAMADhiDB():
>>>     mySamples = Sample.select().where(Sample.author == "MYUSERNAME")
"""

__all__ = ["loadCredentials", "SAMADhiDB"] ## models added below
_models = [] ## list for binding a database

import warnings
warnings.filterwarnings("ignore", module="peewee", category=UserWarning, message="Unable to determine MySQL version: .*")
from peewee import *

def loadCredentials(path="~/.samadhi"):
    import json, os, stat
    credentials = os.path.expanduser(path)
    if not os.path.exists(credentials):
        raise IOError('Credentials file %r not found.' % credentials)
    # Check permission
    mode = stat.S_IMODE(os.stat(credentials).st_mode)
    if mode != int('400', 8):
        raise IOError('Credentials file has wrong permission. Please execute \'chmod 400 %s\'' % credentials)

    with open(credentials, "r") as f:
        data = json.load(f)
    for ky in ("login", "password", "database"):
        if ky not in data:
            raise KeyError("Credentials json file at {0} does not contain '{1}'".format(credentials, ky))
    if "hostname" not in data:
        data["hostname"] = "localhost"

    return data

database = DatabaseProxy()

# Code generated by:
# python -m pwiz -e mysql --host=cp3.irmp.ucl.ac.be --user=llbb --password --info llbb
# Peewee version: 3.9.4
class BaseModel(Model):
    class Meta:
        database = database

class Analysis(BaseModel):
    analysis_id = AutoField()
    cadiline = TextField(null=True)
    contact = TextField(null=True)
    description = TextField(null=True)

    class Meta:
        table_name = 'analysis'

    def __str__(self):
        return ("{0.description}\n"
                "{cadi}"
                "{contact}"
                "  Number of associated results: {nresults:d}"
                ).format(self,
                    cadi=("  CADI line: {0.cadiline}\n".format(self) if self.cadiline else ""),
                    contact=("  Contact/Promotor: {0.contact}\n".format(self) if self.contact else ""),
                    nresults=self.results.count()
                    )

class Dataset(BaseModel):
    """Table to represent one sample from DAS on which we run the analysis"""
    cmssw_release = CharField(null=True)
    creation_time = DateTimeField(null=True)
    dataset_id = AutoField()
    datatype = CharField()
    dsize = BigIntegerField(null=True)
    energy = FloatField(null=True)
    globaltag = CharField(null=True)
    name = CharField(index=True)
    nevents = IntegerField(null=True)
    process = CharField(null=True)
    user_comment = TextField(null=True)
    xsection = FloatField(null=True)

    class Meta:
        table_name = 'dataset'

    @classmethod
    def create(cls, **kwargs):
        """Initialize a dataset by name and datatype. Other attributes may be null and should be set separately"""
        for rK in ("name", "datatype"):
            if rK not in kwargs:
                raise RuntimeError("Argument '{0}' is required to construct {1}".format(rK, self.__class__.__name__))
        if kwargs["datatype"] not in (u"mc", u"data"):
            raise ValueError("dataset type must be mc or data, not {0!r}".format(kwargs["datatype"]))
        super(Dataset, cls).create(*args, **kwargs)

    def __str__(self):
        return ("Dataset #{0.dataset_id:d}:\n"
                "  name: {0.name}\n"
                "  process: {0.process}\n"
                "  cross-section: {0.xsection:f}\n"
                "  number of events: {0.nevents:d}\n"
                "  size on disk: {0.dsize:d}\n"
                "  CMSSW release: {0.cmssw_release}\n"
                "  global tag: {0.globaltag}\n"
                "  type (data or mc): {0.datatype}\n"
                "  center-of-mass energy: {0.energy:f} TeV\n"
                "  creation time (on DAS): {0.creation_time!s}\n"
                "  comment: {0.user_comment}"
                ).format(self)

class Sample(BaseModel):
    """Table to represent one processed sample, typically a PATtupe, skim, RDS, CP, etc."""
    author = TextField(null=True)
    code_version = CharField(null=True)
    creation_time = DateTimeField(constraints=[SQL("DEFAULT CURRENT_TIMESTAMP")])
    event_weight_sum = FloatField(null=True)
    extras_event_weight_sum = TextField(null=True)
    luminosity = FloatField(null=True)
    name = CharField(index=True)
    nevents = IntegerField(null=True)
    nevents_processed = IntegerField(null=True)
    normalization = FloatField(constraints=[SQL("DEFAULT 1")])
    path = CharField()
    processed_lumi = TextField(null=True)
    sample_id = AutoField()
    sampletype = CharField()
    source_dataset = ForeignKeyField(Dataset, backref="samples")
    source_sample = ForeignKeyField("self", null=True, backref="derived_samples")
    user_comment = TextField(null=True)

    class Meta:
        table_name = 'sample'

    @property
    def results(self):
        return Result.select().join(SampleResult).join(Sample).where(Sample.sample_id == self.sample_id)

    SampleTypes = [ "PAT", "SKIM", "RDS", "LHCO", "NTUPLES", "HISTOS", "OTHER" ]

    @classmethod
    def create(cls, **kwargs):
        for rK in ("name", "path", "sampletype", "nevents_processed"):
            if rK not in kwargs:
                raise RuntimeError("Argument '{0}' is required to construct {1}".format(rK, self.__class__.__name__))
        if kwargs["sampletype"] not in Sample.SampleTypes:
            raise ValueError("sample type {0} is unknown (need one of {1})".format(kwargs["sampletype"], ", ".join(Sample.SampleTypes)))
        return super(Sample, cls).create(**kwargs)

    def removeFiles(self):
        File.delete().where(File.sample_id == self.sample_id)
        self.files.clear()
    def getLuminosity(self):
        """Computes the sample (effective) luminosity"""
        if self.luminosity is not None:
            return self.luminosity
        else:
            if self.source_dataset is not None:
                if self.source_dataset.datatype == "MC":
                    # for MC, it can be computed as Nevt/xsection
                    if self.nevents_processed is not None and self.source_dataset.xsection is not None:
                        return self.nevents_processed / self.source_dataset.xsection
                else:
                    # for DATA, it can only be obtained from the parent sample
                    if self.source_sample is not None:
                        return self.source_sample.luminosity
        ## in cases not treated above it is impossible to compute a number, so return None

    def __str__(self):
        return ("Sample #{0.sample_id:d} (created on {0.creation_time!s} by {0.author})\n"
                "  name: {0.name}\n"
                "  path: {0.path}\n"
                "  type: {0.sampletype}\n"
                "  number of processed events: {0.nevents_processed:d}\n"
                "  number of events: {nevents}\n"
                "  normalization: {0.normalization}\n"
                "  sum of event weights: {0.event_weight_sum}\n"
                "{sumw_extras}"
                "  (effective) luminosity: : {0.luminosity}\n"
                "  {hasproclumi} processed luminosity sections information\n"
                "  code version: {0.code_version}\n"
                "  comment: {0.user_comment}\n"
                "  source dataset: {0.source_dataset_id}\n"
                "  source sample: {0.source_sample_id}\n"
                "  {files}"
                ).format(self,
                    nevents=("{0:d}".format(self.nevents) if self.nevents is not None else "none"),
                    sumw_extras=("  has extras sum of event weight\n" if self.extras_event_weight_sum else ""),
                    hasproclumi=("has" if self.processed_lumi else "does not have"),
                    files=("{0:d} files: \n    - {1}".format(self.files.count(),
                            "\n    - ".join(
                                (("{0.lfn} ({0.nevents:d} entries)".format(fl) for fl in self.files)
                                    if self.files.count() < 6 else
                                 (["{0.lfn} ({0.nevents:d} entries)".format(fl) for fl in self.files[:3]]
                                 +["...", "{0.lfn} ({0.nevents:d} entries)".format(self.files[-1])])
                                )
                            )) if self.sample_id else "no files"
                           )
                    )

class File(BaseModel):
    event_weight_sum = FloatField(null=True)
    extras_event_weight_sum = TextField(null=True)
    id = BigAutoField()
    lfn = CharField() # Local file name: /store/
    nevents = BigIntegerField(null=True)
    pfn = CharField() # Physical file name: srm:// or root://
    sample = ForeignKeyField(Sample, backref="files")

    class Meta:
        table_name = 'file'

    @classmethod
    def create(cls, **kwargs):
        for rK in ("lfn", "pfn", "event_weight_sum", "nevents"):
            if rK not in kwargs:
                raise RuntimeError("Argument '{0}' is required to construct {1}".format(rK, self.__class__.__name__))
        return super(File, cls).create(**kwargs)

    def __str__(self):
        return self.lfn

class Result(BaseModel):
    """Table to represent one physics result, combining several samples."""
    analysis = ForeignKeyField(Analysis, null=True, backref="results")
    author = TextField(null=True)
    creation_time = DateTimeField(constraints=[SQL("DEFAULT CURRENT_TIMESTAMP")])
    description = TextField(null=True)
    elog = CharField(null=True)
    path = CharField(index=True)
    result_id = AutoField()

    class Meta:
        table_name = 'result'

    @property
    def samples(self):
        return Sample.select().join(SampleResult).join(Result).where(Result.result_id == self.result_id)

    @classmethod
    def create(cls, **kwargs):
        for rK in ("path",):
            if rK not in kwargs:
                raise RuntimeError("Argument '{0}' is required to construct {1}".format(rK, self.__class__.__name__))
        return super(Result, cls).create(*args, **kwargs)

    def __str__(self):
        return ("Result in {0.path}\n"
                "  created on {0.creation_time!s} by {0.author}"
                "{desc}"
                "{elog}"
                ).format(self,
                    desc=("\n  part of analysis {0.analysis.description}".format(self) if self.analysis else ""),
                    elog=("\n  more details in {0.elog}".format(self) if self.elog else "")
                    )

class SampleResult(BaseModel):
    result_id = ForeignKeyField(Result)
    sample_id = ForeignKeyField(Sample)

    class Meta:
        table_name = 'sampleresult'
        indexes = (
            (('sample_id', 'result_id'), True),
        )
        primary_key = CompositeKey('result_id', 'sample_id')

# all models, for binding in SAMADhiDB and import
_models = [Analysis, Dataset, Sample, File, Result, SampleResult]
__all__ += _models

from contextlib import contextmanager
@contextmanager
def SAMADhiDB(credentials='~/.samadhi'):
    """create a database object and returns the db store from STORM"""
    cred = loadCredentials(path=credentials)
    db = MySQLDatabase(cred["database"], user=cred["login"], password=cred["password"], host=cred["hostname"])
    with db.bind_ctx(_models):
        yield db
